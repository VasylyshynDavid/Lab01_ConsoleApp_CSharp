using System;
using System.Collections.Generic;
using System.Globalization;

namespace ConsoleCalculator
{
    public class Calculator
    {
        public double Calculate(string expression)
        {
            var tokenizer = new Tokenizer();
            var tokens = tokenizer.Tokenize(expression);

            var values = new Stack<double>(); // Стек чисел
            var ops = new Stack<Token>();     // Стек операцій

            for (int i = 0; i < tokens.Count; i++)
            {
                var token = tokens[i];

                if (token.Type == TokenType.Number)
                {
                    // InvariantCulture, щоб "5.5" читалось коректно на будь-якому ПК
                    values.Push(double.Parse(token.Value, CultureInfo.InvariantCulture));
                }
                else if (token.Type == TokenType.OpenParen)
                {
                    ops.Push(token);
                }
                else if (token.Type == TokenType.CloseParen)
                {
                    // Виконуємо все в дужках
                    while (ops.Count > 0 && ops.Peek().Type != TokenType.OpenParen)
                    {
                        values.Push(ApplyOp(ops.Pop(), values));
                    }
                    ops.Pop(); // Викидаємо '('
                }
                else if (IsOperator(token.Type))
                {
                    // Перевірка на унарний мінус (наприклад, -5)
                    if (token.Type == TokenType.Minus)
                    {
                        bool isUnary = (i == 0) || (tokens[i - 1].Type == TokenType.OpenParen);
                        if (isUnary)
                        {
                            values.Push(0);
                        }
                    }

                    // Перевірка пріоритетів
                    while (ops.Count > 0 && HasPrecedence(token.Type, ops.Peek().Type))
                    {
                        values.Push(ApplyOp(ops.Pop(), values));
                    }
                    ops.Push(token);
                }
            }

            // Виконуємо операції, що залишились
            while (ops.Count > 0)
            {
                values.Push(ApplyOp(ops.Pop(), values));
            }

            if (values.Count == 0) return 0;
            return values.Pop();
        }

        private bool IsOperator(TokenType type)
        {
            return type == TokenType.Plus || type == TokenType.Minus ||
                   type == TokenType.Multiply || type == TokenType.Divide ||
                   type == TokenType.Power;
        }

        // Логіка пріоритетів: чи має op2 вищий пріоритет, ніж op1?
        private bool HasPrecedence(TokenType op1, TokenType op2)
        {
            if (op2 == TokenType.OpenParen || op2 == TokenType.CloseParen) return false;
            return GetPriority(op2) >= GetPriority(op1);
        }

        private int GetPriority(TokenType type)
        {
            switch (type)
            {
                case TokenType.Plus:
                case TokenType.Minus: return 1;
                case TokenType.Multiply:
                case TokenType.Divide: return 2;
                case TokenType.Power: return 3; // Степінь найважливіший
                default: return 0;
            }
        }

        private double ApplyOp(Token op, Stack<double> values)
        {
            if (values.Count < 2) throw new Exception("Помилка у виразі: не вистачає чисел.");

            double b = values.Pop();
            double a = values.Pop();

            switch (op.Type)
            {
                case TokenType.Plus: return a + b;
                case TokenType.Minus: return a - b;
                case TokenType.Multiply: return a * b;
                case TokenType.Divide:
                    if (b == 0) throw new DivideByZeroException("Ділення на нуль!");
                    return a / b;
                case TokenType.Power: return Math.Pow(a, b); // Піднесення до степеня
                default: return 0;
            }
        }
    }
}
